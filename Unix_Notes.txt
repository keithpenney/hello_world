Unix Shell and Environment Notes

General:
	Tips for working in the typical Unix environment
	Primarily via a shell (terminal).

Getting Help:
    Man Pages:
        Most commands have an entry in the "man pages" (manual) which can be accessed simply by:
            man CMD
        where 'CMD' is the command in question.
        If you don't quite recall the name of the command, you can try the "-k" (keyword) flag which will return a
        list of command names that match the keyword.
            man -k KW
        where 'KW' is the desired keyword.

        Sections:
            Man pages are broken down into numbered sections.
            To query a particular section, use:
                man N CMD
            where 'N' is the section number (see below) and 'CMD' is the command in question.
            (1)     User commands
            (2)     System calls
            (3)     Higher-level Unix programming library documentation
            (4)     Device interface and driver information
            (5)     File descriptions (system configuration files)
            (6)     Games
            (7)     File formats, conventions, and encodings (ASCII, suffixes, etc.)
            (8)     System commands and servers

    Help:
        The syntax varies from command to command, but you can usually find help by using flags '-h' or '--help'.

    Info/Texinfo:
        Some projects (primarly GNU) opt for "info" (or "texinfo") pages over man pages.  To view these, try:
            info CMD
        where 'CMD' is the command in question.

Shortcuts/Hotkeys/Key Bindings:
    ctrl + _        Undo the last edit (not the last command)
    ctrl + t        Swap two characters
    alt  + t        Swap two words
    alt  + .        Print last argument from previous command
    ctrl + x + *    Expand glob/star
    ctrl + arrow    Move by words (rather than by characters)
    alt  + f        Move forward one word
    alt  + b        Move backward one word
    ctrl + x + ctrl + e     Open the command string in an editor to edit before executing
    ctrl + e        Move cursor to the end
    ctrl + a        Move cursor to the beginning
    ctrl + xx       Move to the opposite end of the line
    ctrl + u        Cut everything before the cursor
    ctrl + k        Cut everything after the cursor
    ctrl + y        Paste from the buffer
    ctrl + l        Clear screen

Common Commands:

    cat [file]                  Concatenate files or StdIn and print to StdOut or redirect.
                                Prints contents of 'file' to StdOut.
    cat > filename              Redirect output from StdIn to 'filename'.  Ctrl+C to terminate.
    chmod                       Change a file's mode bits (read/write/execute)
    clear                       Clear the screen.
    command -V [cmd]            Provide a bit of information about command 'cmd'
    cp -rp FROM TO              Copy a folder (-r recursive) from path FROM to path TO (-p preserve permissions)
    dmesg                       List the last kernel messages (long output! Pipe to 'less'?)
    dpkg -i filename.deb        Install a '.deb' file (always 'sudo' this one).
    df [PATH]                   List filesystem, mount point, device and stats of "PATH" (defaults to all)
    echo                        Print to Standard Out (StdOut)
                                -e: enable escape sequences; -n: suppress trailing newline;
    eject DEV                   Eject a device DEV to make it safe to remove (removes from /dev)
    file FILENAME               Returns file type information about file FILENAME
    find DIR -name FILENAME -print  Prints the location of FILENAME if found in directory DIR
                                Note!  To use globs in the FILENAME, enclose them in single-quotes ''
    findmnt DEVICE              Print the mount point (if any) of DEVICE
    grep PATTERN [file(s)]      Search for and print out all lines in file(s) matching PATTERN
    ifconfig [-a | -s | -v]     Show network InterFace connection information (like Windows ipconfig)
    kill PID                    Terminate a process by its process id (PID).
                                -STOP: pause a process; -CONT: continue after a pause.
    less FILENAME               Read the contents of a long file FILENAME broken up into pages.
    ln -s TARGET LINKNAME       Create a symlink named LINKNAME pointing to TARGET
    ls [DIR]                    List the contents of the directory DIR.  Defaults to current directory.
                                -l : 'long' format.  More detail.
    mount -t TYPE DEVICE DIR    Mount a DEVICE of type TYPE to the file tree at DIR.
    passwd [USERNAME]           Change the password for user USERNAME.  Defaults to current user.
    ps                          List currently running processes.
                                x: only your processes; ax: all processes; u: more info; w: fulll command names
    pwd                         Print the working (current) directory
    read [var]                  Get user input in string form. Stores in 'var' if provided, else in $REPLY
                                -a: read as space-delimited array; 
    set                         Allows you to set the values of shell options and positional parameters.
                                Calling bash with flag -a is the same as opening bash then calling 'set -a'
    seq [begin] [end]           Return a sequence of numbers from 'begin' to 'end'
    stream                      Stream pixel data from one image source to a destination (very lightweight).
    sudo                        Do as superuser (requires password)
    tar                         Archive (zip) or unarchive (unzip) a file.
                                -z: zip; -c: create; -a: append
    tr a-z A-Z                  Translate standard input.  Swap all lowercase chars (a-z) in stdin with uppercase (A-Z)
    umount PATH                 Unmount the device at PATH
    uname                       Print system information
                                -o: OS; -m: machine; -a: all
    which FILENAME              Returns pathnames of the files associated with FILENAME by searching $PATH
    whoami                      Returns the current username

Display Modes:
    Unix/Linux systems have two primary display modes: text mode and graphics mode (X Window System Server)
    Historically, systems booted directly into text mode, but now most distros hide text mode during boot with
    a splash screen and switch to full graphics mode at the end of the boot process.

    Virtual Consoles:
        When a modern Linux system boots, several virtual consoles start and normally just wait for a login.
        Some of these can also be processing a 'getty' command (see below). 
        To switch from a GUI to /dev/tty1 (the first virtual console), press CTRL+ALT+F1 then to switch from
        a virtual console in text mode to any other, press ALT+F* where 'F*' is F1, F2, F3, F4, etc...
        
        You can also switch between virtual consoles with 'chvt *' where '*' is 1, 2, 3, 4, etc...
        Note:
            On kpenney-z97, the GUI is running in /dev/tty7, tty1-6 are all idling at a login prompt.

Shebang:
    Shebang scripts start with #! and are typically the first line of a file.
    These help a Unix-like OS identify the type of file or program associated with it.
    The Windows world uses only the file extension to determine the type, whereas Unix can alternatively use Shebangs

File Permissions:
    File permissions can be viewed with a command like "ls -l" and normally show up as something like:
    -rw-r--r--      # A normal file with user read/write, group read, and other read permissions
    drwxr-xr-x      # A directory with user read/write/execute, group and other read/execute permissions.

    The first character is the file type.  Common file types:
        -           A normal file
        d           A directory
        l           A symlink
        b           Block device: a device which can be indexed for random access (e.g. hard drive)
        c           Character device: a device which interacts by read/write characters (e.g. serial port)
        p           Pipe device: an I/O stream to another process rather than a hardware driver
        s           Socket device: an IPC interface (e.g. Unix domain/BSD socket)

    The next 9 character are 3 groups of 3 characters each: user 'rwx', group 'rwx', other 'rwx'
    'user' is the current user (you). 'group' is the current user's group. 'other' is everyone else.
    If the letter is present, the permission is granted, otherwise the letter is replaced by a hyphen '-'

    chmod:
        To modify file permissions, use the 'chmod' command.  Examples:
            chmod u+x FILE      # Add execution permissions for FILE for the user.
            chmod g-w FILE      # Remove write permissions for FILE for the group.
            chmod go-rw FILE    # Remove read/write permissions for FILE for group and others.
            chmod 644 FILE      # Set user read/write, group/other read permissions for FILE.
            chmod 600 FILE      # Set user read/write, group/other none permissions for FILE.
            chmod 755 FILE      # Set user read/write/execute, group/other read/execute permissions for FILE.

        When you see 'chmod' used with numbers, it's like a bitmask in octal form.  The group of 9 letters is treated
        like a binary number written in octal form where each trio of letters is one octal digit.
        Example:
            rwx = 7
            --x = 1
            r-x = 5
            rw- = 6

    umask:
        You can also specify a common file permission set to assign to all new files created during a session.
        'umask' takes the NEGATION of the 3-digit octal argument discussed in 'chmod' above (it's a MASK!).
        Example:
            umask 077           # All permissions for the user, none for group/other
            umask 022           # All permissions for the user, read/execute (no write) for group/other
        Note that it only applies to subsequently created files during a single session.

Symbolic Links (Symlinks):
    A symbolic link (symlink) is a file that points to another file or directory somewhere else on the disk
    (like a shortcut in Windows).
    You can see where a symlink points in the output of 'ls -l' (e.g. somedir -> some/other/dir)
    Symlinks can be confusing because their name does not necessarily say anything about the destination.
    In fact, the destination may not even exist!  This causes confusing output for programs trying to use
    the symlink.
    Also, the link can point to any type of file/directory (including another symlink!).

    ln -s:
        To create a symbolic link, make sure to use 'ln -s' (without the -s flag, you create a hardlink).
        Keep the syntax in mind:
            ln -s TARGET LINKNAME
        Reversing the order of the arguments can cause some very confusing results.

Archiving and Compression:
    tar:
        An archive is a bunch of files smooshed together into a single file.  The name 'tar' stands for "Tape Archive"
        as it was originally written for copying a directory structure to a tape drive.
        'tar' is used with a variety of flags to control its behavior.  The single-character flags can be concatenated
        and do not need to be preceded with a '-'.  This is why 'tar' is often followed by an opaque jumble of
        characters preceding the filename.
        -c      Create a new archive
        -A      Append tar files to an existing archive
        -r      Append files to the end of an existing archive
        -t      List the contents of an archive
        -u      Only append files newer than copy in archive
        -x      Extract files from an existing archive
        -z      Gzip compress after archiving

        Some flags require an argument; these must be at the end of the string of flags or should be used on their own
        or in their long form (see man(1) tar).
        
        -f FILENAME     Use the archive FILENAME
        
        Example:
            tar czf MyArchive.tar.gz FILE1 FILE2 FILE3  # Combine files into compressed archive MyArchive.tar.gz
            tar xzf MyArchive.tar.gz                    # Extract files from existing archive MyArchive.tar.gz

    gzip:
        GNU zip (gzip) is a file compression tool.  It takes as its input a single uncompressed file, and outputs
        a compressed file, appending the '.gz' extension.
        To unzip, a separate command name 'gunzip' is used.  Example:
            gzip FILENAME       # zip FILENAME to FILENAME.gz
            gunzip FILENAME.gz  # unzip FILENAME.gz to FILENAME

File I/O:
    Unix allows many modes of file interface (some described above).  Here are some helpful programs/commands
    to make file I/O easier.

    dd:
        'dd' reads from an input file and writes to an output file.  It's helpful for both file and device I/O.
        Since 'dd' will read/write whatever you give it, it's easy to mess up and corrupt a file.  Be careful!
        The 'dd' syntax comes from IBM Job Control Language, so it's a little wonky. Example:
            dd if=/dev/zero of=my_new_file bs=1024 count=1

        Arguments:
            'if' is input file
            'of' is output file
            'bs' is block size (how many bytes to write per file operation).  The 'bs' argument can also use
                 key-letters 'b' = 512 and 'k' = 1024 instead of pure bytes
            'ibs' and 'obs' are the input block size and output block size if different (if same, use 'bs')
            'count' is the total number of blocks to copy
            'skip' is the number of blocks in the input file to skip past before copying
 
Device I/O:
    In the Unix world, the kernel presents a user-space interface to a device to make it accessible to the user.
    This interface can take a variety of forms based on device functionality or historical legacy.
    Devices are assigned a major number and a minor number which help identify the device.  These can be found in
    several places including '/proc/devices' and 'ls -l /dev'

    Device Files (/dev):
        Many devices have simple interface files which provide file-like I/O operations (e.g. read/write/seek) to
        the user while the kernel and device drivers handle the translation to the device's API.
        These device files are typically found in the directory /dev.
        Example: to write characters to a character device, you can simply redirect from StdOut.
            echo Hello Device! > /dev/null
            # /dev/null is a bin-bucket (write-only memory, black hole, etc...)

    Common Devices and Naming Conventions:
        /dev/sd*        Hard disk drives
        /dev/sr         CD/DVD drives
        /dev/hd*        Hard disk drives using PATA legacy compatibility (check BIOS to switch to SATA)
        /dev/tty*       Terminals and virtual terminals
        /dev/pts/*      Pseudoterminals
        /dev/tty        The controlling terminal of the current process
        /dev/ttyS*      Serial ports (Windows COM1 would be /dev/ttyS0, COM2 would be /dev/ttyS1, etc.)
        /dev/ttyUSB*    USB-to-serial adapters.  Also show up as /dev/ttyACM*
        /dev/lp*        Parallel ports (old school DB25 style).  Can interface directly with cat > /dev/lp0
        /dev/snd/*      Audio/sound devices (part of the "Advanced Linux Sound Architecture" (ALSA) system)
        /dev/dsp        A legacy sound device interface (see "Open Sound System")

    sysfs Device Path (/sys/devices):
        For many devices, a simple device file interface does not allow exploitation of the device's full
        capabilities.  For this reason (and others), an alternate interface is often provided with a sysfs
        device path.
        The actual sysfs device path can be stupidly long and unintelligible, but helpful symlinks are normally
        provided to find the actual interface path (e.g. /sys/block contains symlinks to all block devices).
        You can also use 'udevadm' to find the device path (see below).

    udev and devtmpfs:
        In the past, new Linux versions would add device compatibility and assign new maj/min numbers which
        would break the /dev filesystem. Then /dev would thus have to be rebuilt for every new release.
        To simplify this process, 'udev' and 'devtmpfs' were created.

        devtmpfs:
            The 'devtmpfs' filesystem is implemented via a collection of kernel-space and user-space programs
            and daemons which keep the hardware, device files, and device paths synchronized.
            Because the kernel needs device files early in the boot process (before 'udev' can start), the
            job of maintaining the 'devtmpfs' filesystem is split between kernel-space and user-space programs.
            Simple example:
                New hardware is detected by the kernel.
                The kernel sends a 'uevent' notification to 'udevd' with the device's attributes.
                'udevd' loads all the attributes and consults its rules to determine actions to take.
                    Default rules are in /lib/udev/rules.d, overrides are in /etc/udev/rules.d
                'udevd' creates symlinks in /dev and elsewhere and does other stuff based on the rules
                and device attributes. 
        udevadm:
            To query device details, the 'udevadm' command is very helpful.  Example:
                udevadm info --query=all --name=/dev/sda
        
            The above command returns a bunch of information (looks like a Windows registry).  The sysfs device
            path follows "DEVTYPE=".

            To monitor 'uevent' events coming from devices, use 'udevadm monitor'.  Example:
                udevadm monitor --kernel
                # Returns only kernel events

    Mounting a Filesystem Device:
        After attaching a new block device (assuming it's already been formatted), you need to first mount the
        filesystem at a chosen path before you can interface with the new block device.
        For example, if I plug in a new USB stick (say 16GB vfat), the new device may show up in /dev as
        something like "/dev/sdc1" (use fdisk -l and/or udevadm to find the device).
        Then I can mount it to a particular location like this:
            sudo mount /dev/sdc1 /media/kpenney/myUSB16GB

        The directory you mount to can be anything you wish.  Common mount points are /mnt, /media/mnt, etc.
        When you're ready to remove the device, use 'umount' and 'eject':
            sudo umount /media/kpenney/myUSB16GB
            sudo eject /dev/sdc1

        To make a permanent association between a device and a mount point, we add a line to our /etc/fstab file:
            /dev/sdc1                       /media/kpenney/myUSB16GB    vfat    defaults    0   0
            /dev/disk/by-uuid/8675-3090     /media/kpenney/myUSB16GB    vfat                0   0

        In the second example, we used the device's UUID since different devices might show up at /dev/sdc1.
        If the device doesn't mount automatically, you can use "mount -a" to mount all unmounted devices.

Job Control:
    You can pause a process by pressing "Ctrl+Z" during operation.
    Once paused, a process can be sent to the background with 'bg' or brought to the foreground with 'fg'
    You can immediately cast a process into the background with the ampersand "&".  Example:
        gunzip myFile.gz &
    This will print the process id and then immediately return you to the prompt, running 'gunzip myFile.gz'
    in the background.
    Note that it might be helpful to redirect output to a file so that it doesn't bug you from the background.


Handy Examples:
    # Search /.../words for pattern 'ie' (returns a lot!) - pipe to 'less' to paginate
    grep ie /usr/share/dict/words | less

