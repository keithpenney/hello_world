Unix/Linux Shell and Environment Notes

Getting Help:
    Man Pages:
        Most commands have an entry in the "man pages" (manual) which can be accessed simply by:
            man CMD
        where 'CMD' is the command in question.
        If you don't quite recall the name of the command, you can try the "-k" (keyword) flag which will return a
        list of command names that match the keyword.
            man -k KW
        where 'KW' is the desired keyword.

        Sections:
            Man pages are broken down into numbered sections.
            To query a particular section, use:
                man N CMD
            where 'N' is the section number (see below) and 'CMD' is the command in question.
            (1)     User commands
            (2)     System calls
            (3)     Higher-level Unix programming library documentation
            (4)     Device interface and driver information
            (5)     File descriptions (system configuration files)
            (6)     Games
            (7)     File formats, conventions, and encodings (ASCII, suffixes, etc.)
            (8)     System commands and servers

    Help:
        The syntax varies from command to command, but you can usually find help by using flags '-h' or '--help'.

    Info/Texinfo:
        Some projects (primarly GNU) opt for "info" (or "texinfo") pages over man pages.  To view these, try:
            info CMD
        where 'CMD' is the command in question.

User vs. Kernel:
    Unix/Linux is broken up into various layers of abstraction.
    User Processes:
        GUIs, servers, shells, ...
    Kernel Processes:
        The Kernel (aka "OS"), system calls, process management, memory management, device drivers, ...
    Hardware:
        Processor (CPU), main memory (RAM), disks, network adapters, ...

    Code running in "Kernel Mode" has unlimited access to the processor and RAM.
    Code running in "User Mode" has limited access system resources and must go through the Kernel for access.
    Memory is broken up between "Kernel Space" (memory only the Kernel can access) and "User Space" (memory that
    user processes can access).

Display Modes:
    Unix/Linux systems have two primary display modes: text mode and graphics mode (X Window System Server)
    Historically, systems booted directly into text mode, but now most distros hide text mode during boot with
    a splash screen and switch to full graphics mode at the end of the boot process.

    Virtual Consoles:
        When a modern Linux system boots, several virtual consoles start and normally just wait for a login.
        Some of these can also be processing a 'getty' command (see below). 
        To switch from a GUI to /dev/tty1 (the first virtual console), press CTRL+ALT+F1 then to switch from
        a virtual console in text mode to any other, press ALT+F* where 'F*' is F1, F2, F3, F4, etc...
        
        You can also switch between virtual consoles with 'chvt *' where '*' is 1, 2, 3, 4, etc...
        Note:
            On kpenney-z97, the GUI is running in /dev/tty7, tty1-6 are all idling at a login prompt.

Shell Shortcuts/Hotkeys/Key Bindings:
    ctrl + _        Undo the last edit (not the last command)
    ctrl + t        Swap two characters
    alt  + t        Swap two words
    alt  + .        Print last argument from previous command
    ctrl + x + *    Expand glob/star
    ctrl + arrow    Move by words (rather than by characters)
    alt  + f        Move forward one word
    alt  + b        Move backward one word
    ctrl + x + ctrl + e     Open the command string in an editor to edit before executing
    ctrl + e        Move cursor to the end
    ctrl + a        Move cursor to the beginning
    ctrl + xx       Move to the opposite end of the line
    ctrl + u        Cut everything before the cursor
    ctrl + k        Cut everything after the cursor
    ctrl + y        Paste from the buffer
    ctrl + l        Clear screen

Common Shell Commands:

    blkid                       View all block devices, UUIDs, and filesystem types.
    cat [file]                  Concatenate files or StdIn and print to StdOut or redirect.
                                Prints contents of 'file' to StdOut.
    cat > filename              Redirect input from StdIn to 'filename'.  Ctrl+C to terminate.
    chmod                       Change a file's mode bits (read/write/execute)
    clear                       Clear the screen.
    command -V [cmd]            Provide a bit of information about command 'cmd'
    cp -rp FROM TO              Copy a folder (-r recursive) from path FROM to path TO (-p preserve permissions)
    dmesg                       List the last kernel messages (long output! Pipe to 'less'?)
    dpkg -i filename.deb        Install a '.deb' file (always 'sudo' this one).
    df [PATH]                   List filesystem, mount point, device and stats of "PATH" (defaults to all)
    du [-s] *                   List disk usage of every subdirectory of the current directory (-s: summary).
    echo                        Print to Standard Out (StdOut)
                                -e: enable escape sequences; -n: suppress trailing newline;
    eject DEV                   Eject a device DEV to make it safe to remove (removes from /dev)
    file FILENAME               Returns file type information about file FILENAME
    find DIR -name FILENAME -print  Prints the location of FILENAME if found in directory DIR
                                Note!  To use globs in the FILENAME, enclose them in single-quotes ''
    findmnt DEVICE              Print the mount point (if any) of DEVICE
    free                        View current RAM and swap usage.
    grep PATTERN [file(s)]      Search for and print out all lines in file(s) matching PATTERN
                                -i: case insensitive; -n: print line numbers
    ifconfig [-a | -s | -v]     Show network InterFace connection information (like Windows ipconfig)
    kill PID                    Terminate a process by its process id (PID).
                                -STOP: pause a process; -CONT: continue after a pause.
    less FILENAME               Read the contents of a long file FILENAME broken up into pages.
    ln -s TARGET LINKNAME       Create a symlink named LINKNAME pointing to TARGET
    ls [DIR]                    List the contents of the directory DIR.  Defaults to current directory.
                                -l: 'long' format (more detail); -i: print inode numbers.
    mount -t TYPE DEVICE DIR    Mount a DEVICE of type TYPE to the file tree at DIR.
    passwd [USERNAME]           Change the password for user USERNAME.  Defaults to current user.
    ps                          List currently running processes.
                                x: only your processes; ax: all processes; u: more info; w: fulll command names
    pwd                         Print the working (current) directory
    read [var]                  Get user input in string form. Stores in 'var' if provided, else in $REPLY
                                -a: read as space-delimited array; 
    set                         Allows you to set the values of shell options and positional parameters.
                                Calling bash with flag -a is the same as opening bash then calling 'set -a'
    seq [begin] [end]           Return a sequence of numbers from 'begin' to 'end'
    stat FILE                   Return a bunch of statistics about file FILE (including inode number, link count)
    stream                      Stream pixel data from one image source to a destination (very lightweight).
    sudo                        Do as superuser (requires password)
    tar                         Archive (zip) or unarchive (unzip) a file.
                                -z: zip; -c: create; -a: append
    tr a-z A-Z                  Translate standard input.  Swap all lowercase chars (a-z) in stdin with uppercase (A-Z)
    umount PATH                 Unmount the device at PATH
    uname                       Print system information
                                -o: OS; -m: machine; -a: all
    which FILENAME              Returns pathnames of the files associated with FILENAME by searching $PATH
    whoami                      Returns the current username

File Permissions:
    File permissions can be viewed with a command like "ls -l" and normally show up as something like:
    -rw-r--r--      # A normal file with user read/write, group read, and other read permissions
    drwxr-xr-x      # A directory with user read/write/execute, group and other read/execute permissions.

    The first character is the file type.  Common file types:
        -           A normal file
        d           A directory
        l           A symlink
        b           Block device: a device which can be indexed for random access (e.g. hard drive)
        c           Character device: a device which interacts by read/write characters (e.g. serial port)
        p           Pipe device: an I/O stream to another process rather than a hardware driver
        s           Socket device: an IPC interface (e.g. Unix domain/BSD socket)

    The next 9 character are 3 groups of 3 characters each: user 'rwx', group 'rwx', other 'rwx'
    'user' is the current user (you). 'group' is the current user's group. 'other' is everyone else.
    If the letter is present, the permission is granted, otherwise the letter is replaced by a hyphen '-'

    chmod:
        To modify file permissions, use the 'chmod' command.  Examples:
            chmod u+x FILE      # Add execution permissions for FILE for the user.
            chmod g-w FILE      # Remove write permissions for FILE for the group.
            chmod go-rw FILE    # Remove read/write permissions for FILE for group and others.
            chmod 644 FILE      # Set user read/write, group/other read permissions for FILE.
            chmod 600 FILE      # Set user read/write, group/other none permissions for FILE.
            chmod 755 FILE      # Set user read/write/execute, group/other read/execute permissions for FILE.

        When you see 'chmod' used with numbers, it's like a bitmask in octal form.  The group of 9 letters is treated
        like a binary number written in octal form where each trio of letters is one octal digit.
        Example:
            rwx = 7
            --x = 1
            r-x = 5
            rw- = 6

    umask:
        You can also specify a common file permission set to assign to all new files created during a session.
        'umask' takes the NEGATION of the 3-digit octal argument discussed in 'chmod' above (it's a MASK!).
        Example:
            umask 077           # All permissions for the user, none for group/other
            umask 022           # All permissions for the user, read/execute (no write) for group/other
        Note that it only applies to subsequently created files during a single session.

Shebang:
    Shebang scripts start with #! and are typically the first line of a file.
    These help a Unix-like OS identify the type of file or program associated with it.
    The Windows world uses only the file extension to determine the type, whereas Unix can alternatively use Shebangs

Symbolic Links (Symlinks):
    A symbolic link (symlink) is a file that points to another file or directory somewhere else on the disk
    (like a shortcut in Windows).
    You can see where a symlink points in the output of 'ls -l' (e.g. somedir -> some/other/dir)
    Symlinks can be confusing because their name does not necessarily say anything about the destination.
    In fact, the destination may not even exist!  This causes confusing output for programs trying to use
    the symlink.
    Also, the link can point to any type of file/directory (including another symlink!).

    ln -s:
        To create a symbolic link, make sure to use 'ln -s' (without the -s flag, you create a hardlink).
        Keep the syntax in mind:
            ln -s TARGET LINKNAME
        Reversing the order of the arguments can cause some very confusing results.

Archiving and Compression:
    tar:
        An archive is a bunch of files smooshed together into a single file.  The name 'tar' stands for "Tape Archive"
        as it was originally written for copying a directory structure to a tape drive.
        'tar' is used with a variety of flags to control its behavior.  The single-character flags can be concatenated
        and do not need to be preceded with a '-'.  This is why 'tar' is often followed by an opaque jumble of
        characters preceding the filename.
        -c      Create a new archive
        -A      Append tar files to an existing archive
        -r      Append files to the end of an existing archive
        -t      List the contents of an archive
        -u      Only append files newer than copy in archive
        -x      Extract files from an existing archive
        -z      Gzip compress after archiving

        Some flags require an argument; these must be at the end of the string of flags or should be used on their own
        or in their long form (see man(1) tar).
        
        -f FILENAME     Use the archive FILENAME
        
        Example:
            tar czf MyArchive.tar.gz FILE1 FILE2 FILE3  # Combine files into compressed archive MyArchive.tar.gz
            tar xzf MyArchive.tar.gz                    # Extract files from existing archive MyArchive.tar.gz

    gzip:
        GNU zip (gzip) is a file compression tool.  It takes as its input a single uncompressed file, and outputs
        a compressed file, appending the '.gz' extension.
        To unzip, a separate command name 'gunzip' is used.  Example:
            gzip FILENAME       # zip FILENAME to FILENAME.gz
            gunzip FILENAME.gz  # unzip FILENAME.gz to FILENAME

File I/O:
    Unix allows many modes of file interface (some described above).  Here are some helpful programs/commands
    to make file I/O easier.

    dd:
        'dd' reads from an input file and writes to an output file.  It's helpful for both file and device I/O.
        Since 'dd' will read/write whatever you give it, it's easy to mess up and corrupt a file.  Be careful!
        The 'dd' syntax comes from IBM Job Control Language, so it's a little wonky. Example:
            dd if=/dev/zero of=my_new_file bs=1024 count=1

        Arguments:
            'if' is input file
            'of' is output file
            'bs' is block size (how many bytes to write per file operation).  The 'bs' argument can also use
                 key-letters 'b' = 512 and 'k' = 1024 instead of pure bytes
            'ibs' and 'obs' are the input block size and output block size if different (if same, use 'bs')
            'count' is the total number of blocks to copy
            'skip' is the number of blocks in the input file to skip past before copying
 
Device I/O:
    In the Unix world, the kernel presents a user-space interface to a device to make it accessible to the user.
    This interface can take a variety of forms based on device functionality or historical legacy.
    Devices are assigned a major number and a minor number which help identify the device.  These can be found in
    several places including '/proc/devices' and 'ls -l /dev'

    Device Files (/dev):
        Many devices have simple interface files which provide file-like I/O operations (e.g. read/write/seek) to
        the user while the kernel and device drivers handle the translation to the device's API.
        These device files are typically found in the directory /dev.
        Example: to write characters to a character device, you can simply redirect from StdOut.
            echo Hello Device! > /dev/null
            # /dev/null is a bin-bucket (write-only memory, black hole, etc...)

    Common Devices and Naming Conventions:
        /dev/sd*        Hard disk drives
        /dev/sr         CD/DVD drives
        /dev/hd*        Hard disk drives using PATA legacy compatibility (check BIOS to switch to SATA)
        /dev/tty*       Terminals and virtual terminals
        /dev/pts/*      Pseudoterminals
        /dev/tty        The controlling terminal of the current process
        /dev/ttyS*      Serial ports (Windows COM1 would be /dev/ttyS0, COM2 would be /dev/ttyS1, etc.)
        /dev/ttyUSB*    USB-to-serial adapters.  Also show up as /dev/ttyACM*
        /dev/lp*        Parallel ports (old school DB25 style).  Can interface directly with cat > /dev/lp0
        /dev/snd/*      Audio/sound devices (part of the "Advanced Linux Sound Architecture" (ALSA) system)
        /dev/dsp        A legacy sound device interface (see "Open Sound System")

    sysfs Device Path (/sys/devices):
        For many devices, a simple device file interface does not allow exploitation of the device's full
        capabilities.  For this reason (and others), an alternate interface is often provided with a sysfs
        device path.
        The actual sysfs device path can be stupidly long and unintelligible, but helpful symlinks are normally
        provided to find the actual interface path (e.g. /sys/block contains symlinks to all block devices).
        You can also use 'udevadm' to find the device path (see below).

    udev and devtmpfs:
        In the past, new Linux versions would add device compatibility and assign new maj/min numbers which
        would break the /dev filesystem. Then /dev would thus have to be rebuilt for every new release.
        To simplify this process, 'udev' and 'devtmpfs' were created.

        devtmpfs:
            The 'devtmpfs' filesystem is implemented via a collection of kernel-space and user-space programs
            and daemons which keep the hardware, device files, and device paths synchronized.
            Because the kernel needs device files early in the boot process (before 'udev' can start), the
            job of maintaining the 'devtmpfs' filesystem is split between kernel-space and user-space programs.
            Simple example:
                New hardware is detected by the kernel.
                The kernel sends a 'uevent' notification to 'udevd' with the device's attributes.
                'udevd' loads all the attributes and consults its rules to determine actions to take.
                    Default rules are in /lib/udev/rules.d, overrides are in /etc/udev/rules.d
                'udevd' creates symlinks in /dev and elsewhere and does other stuff based on the rules
                and device attributes. 
        udevadm:
            To query device details, the 'udevadm' command is very helpful.  Example:
                udevadm info --query=all --name=/dev/sda
        
            The above command returns a bunch of information (looks like a Windows registry).  The sysfs device
            path follows "DEVTYPE=".

            To monitor 'uevent' events coming from devices, use 'udevadm monitor'.  Example:
                udevadm monitor --kernel
                # Returns only kernel events

    Mounting a Filesystem Device:
        After attaching a new block device (assuming it's already been formatted), you need to first mount the
        filesystem at a chosen path before you can interface with the new block device.
        For example, if I plug in a new USB stick (say 16GB vfat), the new device may show up in /dev as
        something like "/dev/sdc1" (use fdisk -l and/or udevadm to find the device).
        Then I can mount it to a particular location like this:
            sudo mount /dev/sdc1 /media/kpenney/myUSB16GB

        The directory you mount to can be anything you wish.  Common mount points are /mnt, /media/mnt, etc.
        When you're ready to remove the device, use 'umount' and 'eject':
            sudo umount /media/kpenney/myUSB16GB
            sudo eject /dev/sdc1

        To make a permanent association between a device and a mount point, we add a line to our /etc/fstab file:
            /dev/sdc1                       /media/kpenney/myUSB16GB    vfat    defaults    0   0
            /dev/disk/by-uuid/8675-3090     /media/kpenney/myUSB16GB    vfat                0   0

        In the second example, we used the device's UUID since different devices might show up at /dev/sdc1.
        If the device doesn't mount automatically, you can use "mount -a" to mount all unmounted devices.

        mount options:
            -o [fs-option]              # Specify a filesystem-specific option
            -r                          # Mount as read-only
            -n                          # Do not update runtime mount database /etc/mtab (useful at boot time)
            -t [fs-type]                # Specify a filesystem type.  Sometimes 'mount' can guess correctly.
            [The following options must all follow a -o flag]
            exec/noexec                 # Enabled/disables program executions on the filesystem
            suid/nosuid                 # Enables or disables setuid programs.
            ro                          # Mount as read-only (same as -r above)
            rw                          # Mount as read/write
            conv=RULE                   # Convert newline characters (e.g. for FAT) based on RULE=binary/text/auto
            remount                     # Remount a filesystem (see below).

        Remounting:
            There are times when you'll need to remount a filesystem (e.g. after a change to /etc/fstab).
                mount -n -o remount /   # Remount the main filesystem at / (root).
            This assumes the device is listed in /etc/fstab.  If not, you must specify the device.

    Unmounting:
        Modern operating systems buffer disk operations in a cache to speed up the user interface and minimize
        costly writes to the disk.  But this means that even after completing all write tasks, a filesystem device
        has not necessarily received the bytes (e.g. they could still be in the cache).  This is rare, but it's
        good practice to do the following before disconnecting a filesystem device:
            umount /dev/mydevice        # Detach the device from its mount point
            sync                        # Ensure all cached write operations are completed
            eject /dev/mydevice         # Finally remove /dev/mydevice from the device table

Partitions:
    The first block of memory on a disk is reserved for the partition table.  There are two primary types of
    partition tables: Master Boot Record (MBR) and Globally Unique Identifier Partition Table (GPT)
    
    Primary partition:  A normal partition of the disk.  Normal MBR supports up to 4 of these.
    Extended partition: A partition beyond the normal 4 primary partitions.
    Logical partition:  An extended partition is broken up into logical partitions.

    View Partitions:
        parted      A text-based partitioning tool that supports both MBR and GPT.
        gparted     A graphical version of 'parted'
        fdisk       A text-based partitioning tool that supports only MBR.
        gdisk       A version of fdisk that supports GPT, but not MBR.

        parted -l           View current disks and partitions.  Output depends on the partition table type:
                            Number  Start   End Size    Type    File System Flags   // for MBR (aka 'msdos')
                            Number  Start   End Size    File System Name    Flags   // for GPT

    Modify Partitions:
        There's a key difference between the operation of parted/gparted and fdisk/gdisk.
        While 'fdisk' will only modify the partition table when you perform a "save and exit", allowing you to
        view and modify your desired configuration before any changes are made, 'parted' makes changes to the
        partition table immediately as you execute commands.  This makes it very easy to mess up with 'parted'
        where 'fdisk' is a bit more forgiving.

    Paritions and Disks:
        On older hard disk drives, it was critical for performance to ensure your partitions lined up with cylinder
        boundaries on the disk itself and each partition was made of contiguous cylinders.  Modern disk drives
        implement a more user-friendly architecture than ensures partitioning is optimized for performance.
        Solid state drives don't have cylinders (obviously), but they do perform reads in big chunks (e.g. 4096 bytes)
        so if partition boundaries don't line up with these chunks, small disk operations (like directory reads) can
        take extra time by requiring two reads instead of one.
        parted/gparted has utilities that ensure your partition alignment is optimized.

Filesystems:
    A filesystem is what turns a simple block device into a hierarchy of files and directories; without it a block
    device is simply a continuous chunk of memory with poorly defined boundaries (if any).
    Originally designed simply to provide a navigable interface to a data storage medium, filesystems have evolved
    to incorporate a variety of other features like system interfaces.

    Virtual File System (VFS): a standardized abstraction layer for filesystem interfaces.  With VFS, user-space
    programs can interface with many different filesystems in a uniform manner.

    File system in USEr space (FUSE): allows user-space filesystems in Linux.  Most filesystems are implemented in
    the kernel and require kernel calls to interface with user-space programs.

    Fourth Extended Filesystem (ext4):
        The latest (as of 2018) iteration of a line of filesystems native to Linux.  ext2 was based on the Unix
        File System (UFS) and the Fast File System (FFS) and was a longtime standard for Linux systems.
        ext3 added a journal feature which improved data integrity and sped up the boot process.
        ext4 added support for larger files and deeper directory trees.
        Note: ext2 and ext3 can be mounted as ext4, but ext4 cannot be mounted as either ext2 or ext3.
        Note: new filesystems are being developed for Linux - see 'btrfs'
    
    FAT filesystems (msdos, vfat, umsdos):
        These are Microsoft's native filesystems.  'msdos' is the name given to anything FAT32 or prior.
        The msdos system (aka FAT32), does not distinguish between cases (upper/lowercase) for file/directory names.
        The vfat system supports long filenames, journaling, new encryption algorithms, hardlinks.
        The umsdos system is an oddball msdos system with Unix features added on.
        Of course, all modern Windows systems use NTFS filesystems.  Unix has free drivers available for NTFS.

    HFS+ (hfsplus):
        HFS+ is an Apple filesystem that improves on the older HFS and is used on most Apple/Macintosh devices.
        It supports long filenames, journaling, hard links, etc.
        It is beginning to be replaces by the Apple Filesystem (APFS) as of 2017.

    ISO 9660 (iso9660):
        This is the standard filesystem for CD-ROM.

    Special-Purpose Filesystems:
        Unix has implemented several instances of using a filesystem to serve as a type of system interface,
        rather than representing data stored on a physical device somewhere.  Here are some examples:

        proc:
            Mounted on /proc
            Each numbered directory in /proc is the process ID of a current process on the system.
            The files within each subdirectory represent different aspects of the process.

        sysfs:
            Mounted on /sys
            Allows for a more elaborate device interface than the simple /dev location.

        tmpfs:
            Mounted on /run (and other locations).
            Allows using physical memory as a temporary file storage location.

    View Currently Mounted Filesystems:
        The command 'df' will list all currently mounted filesystems, their available space, used space,
        device name, and mount point.
        The command 'du' will list the disk usage of every directory in the hierarchy, walking the tree from
        your current directory.  This output can be verbose.  Try using 'du -s' for a summary instead.

    Making a Filesystem:
        Once you've installed a new disk/drive and properly formatted its partitions, you're ready to create a
        filesystem on the drive.  The 'mkfs' command (which actually redirects to another program based on the
        target filesystem) is an easy user-space command for this job.
            mkfs -t ext4 /dev/sdf2      # Assuming the device is at /dev/sdf2 and you want an ext4 filesystem
            mkfs.ext4 /dev/sdf2         # This is called by mkfs (equivalent)
            mke2fs -t ext4 /dev/sdf2    # This is called by mkfs.ext4 (so much abstraction!)

        Any of the above commands can be called to do the same job; they're equivalent.  Any options not specified
        in the command are controlled by defaults stored in /etc/mke2fs.conf

    Mounting a Filesystem:
        The last step to adding a disk/drive is to mount your newly created filesystem using 'mount'.
        See "Mounting a Filesystem Device" above.
            mount -t ext4 /dev/sdf2 /home/newdrive      # Assuming /home/newdrive is your desired mount point
            mount UUID=5ac31dba-f30b-801a-e4ca-3ldf0076fdee /home/newdrive  # You can find your UUID with 'blkid'

    The Filesystem Table (/etc/fstab):
        Linux keeps a permanent list of filesystems and mount options to automatically mount on bootup.
        The devices, mount points, and mount options are listed in a simple plaintext file '/etc/fstab'.
        Each line corresponds to one filesystem and has the following structure.
            dev/UUID    mount-point     fs-type     options     backup-info     fs-test-order

        'options' are a list of long options (see 'mount options' above) separated by commas.
        'backup-info' should always be zero '0' (used by the 'dump' command).
        'fs-test-order' should be 1 for the root filesystem, 2 for other filesystems, and 0 for everything else

    Checking and Repairing a Filesystem:
        The kernel trust the filesystem completely (assumes no errors).  Errors in the filesystem can result
        from unexpected power outages, disk failures, improper device unmounting, etc.
        Modern filesystems which use journaling are far less prone to filesystem errors, but checks should
        still be done periodically.  This can be done with command 'fsck' (FileSystem ChecK).

        Warning!  Only run fsck on an unmounted device as the kernel could otherwise alter the disk data while
        the check is running.  The only exception is with the root partition mounted in read-only single-user mode.
            fsck /dev/sdb1              # Run fsck on device /dev/sdb1 in interactive manual mode

        In interactive manual mode, fsck will stop on an error and ask you how you would like to proceed.
        If fsck encounters a "loose inode", it has found a file that appears to have no filename.  These files
        are collected in the "lost+found" directory for manual renaming by the user.

        fsck flags:
            -p          # Automatically fix common errors
            -a          # Same as -p
            -n          # Check the filesystem without modifying anything
            -fy         # e2fsck only!  Flush the journal to the filesystem database.  
                        # The kernel will not mount a filesystem with a non-empty journal.

        Worst-Case Scenario:
            If the filesystem is really messed up, try one of the following:
                Use 'dd' to copy the entire filesystem to another partition of the same size.
                Repair (as much as possible) and mount the filesystem in read-only mode and copy data manually.
                Use 'debugfs' command (which pretty much just does the above option).

    Swap Space:
        If you run out of physical memory (RAM), the Linux virtual memory system can make use of the disk by
        moving pieces of memory to and from a reserved section of the disk called "swap space."
        Normally only blocks of memory associated with idle programs are "swapped" to the disk.
        Use the command 'free' to view the current swap usage.

        Using a Disk Partition as Swap Space:
            To use an entire disk partition as swap space:
                1. Ensure the partition is empty.
                2. Run "mkswap DEVICE" (where "DEVICE" is the partition's device path).
                3. Run "swapon DEVICE" to register the space with the kernel.
                4. (optional) Add an entry to /etc/fstab to use the partition as swap space on bootup.

        Using a File as Swap Space:
            If you would rather not repartition a drive to make some swap space, you can use a normal file.
            To do so, run the following with "SWAPFILE" as the name of the new file to use as swap space and
            "NUM_MB" the file size in megabytes (MB).
                dd if=/dev/zero of=SWAPFILE bs=1024k count=NUM_MB   # Recall /dev/zero is a source of zeros
                mkswap SWAPFILE
                swapon SWAPFILE

        To remove a file or partition from swap space, use "swapoff DEVICE".

    Structure of a (Traditional Unix) Filesystem:
        Traditional Unix filesystems are made up of a section of data blocks and a database system that manages
        the connections between the data blocks.  Note that even if new filesystems don't operate in this manner,
        the Unix Virtual FileSystem (VFS) ensures that programs that expect this kind of interaction can still
        function on them without too much modification.

        Inodes:
            An inode is a set of data that describes a file.
            Includes filename, type, permissions, and a pointer to the top of the file in the data blocks.
            Inodes are assigned numbers (inode numbers) and are appended to the "inode table" for lookup.
        
        Link Count:
            Each inode has an associated link count.  This is the number of pointers that reference it.
            Each time a pointer is created to reference the inode (e.g. a hardlink), the link count is
            incremented.  Each time one of those pointers is deleted (removed), the link count is decremented.
            When the link count reaches 0, the Kernel can overwrite the data at that data block.
            Note: the link count of directories tends to be >1 because each subdirectory has a '..' link
            to its parent directory.

        Viewing Inode Details:
            The 'stat' command shows a file's inode number, link count, and various other details.
            The '-i' flag of command 'ls' shows the inode number for each entry in the directory.

        Block Bitmap:
            The block bitmap is a series of reserved bytes with each bit representing a block of memory.
            A '0' at a bit means its corresponding memory block is free for writing, a '1' means it's in use.

Job Control:
    You can pause a process by pressing "Ctrl+Z" during operation.
    Once paused, a process can be sent to the background with 'bg' or brought to the foreground with 'fg'
    You can immediately cast a process into the background with the ampersand "&".  Example:
        gunzip myFile.gz &
    This will print the process id and then immediately return you to the prompt, running 'gunzip myFile.gz'
    in the background.
    Note that it might be helpful to redirect output to a file so that it doesn't bug you from the background.


Handy Examples:
    # Search /.../words for pattern 'ie' (returns a lot!) - pipe to 'less' to paginate
    grep ie /usr/share/dict/words | less

